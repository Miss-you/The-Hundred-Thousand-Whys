# linux

## 如何区分一个 linux 命令的 shell 输出是 stdin、还是 stderr 呢？举个具体的例子，curl -v 或者-i 返回的结果是标准 stdin，还是 stderr？

1. linux 中一切设备皆是文件，包括 stdin/stdout/stderr。那他们是指哪个文件？
2. 以 stdin 为例，使用命令`find / -name stdin`查找，其对应 linux 文件为/dev/stdin。那么它是什么样的文件类型？[1]
3. 使用 ls -l 可以查看文件类型，其结果为`lrwxrwxrwx 1 root root 15 Mar 26 20:45 /dev/stdin -> /proc/self/fd/0`，故它是链接文件，我们也可以看到它刚好对应的就是/proc/self/fd/0。这里能看出什么呢？
4. 分别 ls -l 查看 stdin/stdout/stderr，他们刚好对应的就是`fd/0,fd/1,fd/2`，也就是大家常说的 stdin 对应 0，balabala……。在实际中，shell 中怎么使用呢？
5. `curl url > stdin.log 2>stderr.log`，标准输出会到 stdin.log 文件，错误输出会到 stderr.log 文件。正如第四条，1 对应标准输出 stdout，2 对应标准错误 stderr。再回到原问，怎么区分 stdout 和 stderr 的输出呢？
6. 可以将输出替换为有颜色的，比如`\e[91m`是红色，`\e[92m`是绿色，`\e[93m`是黄色。示例命令：`curl -v 111.230.86.254 > >(sed $'s/.*/\e[92m&\e[m/')  2> >(sed $'s/.*/\e[91m&\e[m/'>&2)`。有兴趣的可以自己试试。最后再思考一点，代码里面 stdout 和 stderr 对应什么呢？
7. golang 是 `os.Stdin/os.Stderr`，C 是 `stdout/stderr`，比如`fprintf(stdout,"hello world!\n");`。

[1] linux 文件类型：
- 普通文件
- 字符设备文件
- 块设备文件
- 目录文件
- 链接文件
- 管道文件
- 套接字文件

## linux 查看文件类型的方法

## objdump 命令常用参数有哪些？分别有啥用，解决什么问题？

我常用如下：

- objdump -o，查看符号表
- objdump -g，查看是否开了调试参数（这样才能 gdb/dlv 调试）

## hostname 有什么用？

每次登录到 linux 上，就会看到`yousali@nj-9-113-20-175:~$   `这样的提示符，@后面的就是`nj-9-113-20-175`

```
yousali@nj-9-113-20-175:~$ hostname
nj-9-113-20-175
```

hostname 的用途：
a. 可以知道自己是不是登录错机器了。
b. 在本机的`/etc/hosts`文件中添加经常访问的机器的 ip 地址和主机名的映射关系，下次访问时，可以`ssh yousali@nj-9-113-20-175`来登录，不用记住 IP 地址了（前提是人家的 ip 没有变）。

可以通过如下方式修改 hostname
- ubuntu 在这个文件中  /etc/hostname
- centos 系统是在这个文件中 /etc/sysconfig/network 

## 为什么需要内存对齐？

进行内存对齐的原因：（主要是硬件设备方面的问题）

1. 部分不支持。某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；
2. 原子操作。某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；
3. 性能差。相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；
4. 特殊 bug。某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；
5. 支持不完善。某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。

内存对齐的优点：

1. 可移植性好。便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；
2. 对齐内存读取性能高。提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。

## 产生死锁的条件

1. 互斥条件。资源是独占的且排他使用。即任意时刻一个资源只能给一个进程使用，其他申请者只有等待，直到资源被占有者释放。如例子中的Ａ，Ｂ资源。
2. 不可剥夺条件。进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，而只能由拥有该资源的进程自愿释放。如例子中 P2 不能强占 P1 拥有的 A 资源，而 P1 也不能强占 P2 拥有的 B 资源。
3. 请求和保持条件。进程每次申请他所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。如例子中 P1 申请 B 资源时继续占有 A 资源，P2 申请 A 资源时继续占有 B 资源。
4. 循环等待条件。在发生死锁时，必然存在一个进程等待环路，环路中的每一个进程已占有的资源同时被另一个进程所申请。如例子中的 P1 和 P2 就是一个简单的等待环路。

## shell 与 gdb 环境转换

在 gdb 调试环境中，经常有时候需要切换到 linux 的 shell 界面进行其他操作。

这个时候可以通过不开一个新的 shell 或者不中断 gdb 调试就可以直接操作。

只要在 gdb 调试环境中执行命令 shell（简写 she）就可以切换到 linux 的 shell 命令环境下。如果想切换回来，则在 shell 下输入 exit 命令就可以切换回 gdb 模式。

## 孤儿进程和僵尸进程

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被 init 进程（进程号为 1) 所收养，并由 init 进程对它们完成状态收集工作。

僵尸进程：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

## linux 查看磁盘使用情况命令

1. df 命令的功能是用来检查 linux 服务器的文件系统的磁盘空间占用情况。
2. 查看当前目录磁盘使用情况，`df -h`
3. 查看指定目录磁盘使用情况，`df -h /data/`
4. du 命令用于显示目录或文件的大小，du 会显示指定的目录或文件所占用的磁盘空间。
5. 查看当前目录每个文件夹的情况，`du --max-depth=1 -h `
6. 查看指定目录每个文件夹的情况，`du --max-depth=1 -h  /data/`
7. 计算指定文件夹大小，`du -sh /data/`
